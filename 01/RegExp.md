## 正则表达式

什么是正则表达式呢？举一个大家都比较熟悉的例子。我们在注册账户时，时常提交时浏览器提醒你，你的密码强度不够，或者说你的密码格式不对。

那么浏览器是怎么识别的呢？这就需要用到正则表达式。



正则表达式出奇地复杂和难以阅读，尽管它可以简化，但简化之后又容易变得抽象。所以我们折衷了一下，让代码虽然复杂了一些，却更加容易理解。



在JavaScript中，正则表达式必须写在一行中，空白需要特别注意。

```javascript
const parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
const url = "http://www.ora.com:80/goodparts?q#frament";

const result = parse_url.exec(url);

const names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
const blanks = '    ';

for(let i = 0; i < names.length; i++) {
    console.log(names[i] + ':' +
    blanks.substring(names[i].length), result[i]);
}
```

这段代码的执行结果如下：

```javascript
url:  http://www.ora.com:80/goodparts?q#frament
scheme: http
slash: //
host: www.ora.com
port: 80
path: goodparts
query: q
hash: frament
```



下面我们要来一步一步分解这个表达式是如何解析的。

​	<strong><font size = '6'>^</font></strong>

表示此字符串的开始。它是一个锚，指引**exec**不要跳过那些不像**URL**的前缀，只匹配那些从开头**URL**一样的字符串



<strong><font size = '6'>(?:([A-Za-z]+):)?</font></strong>

这个银子匹配一个协议名，但仅当它后面跟随一个 **:** (冒号)的时候才匹配。

**(?: .  .  .  .  )** 表示一个非捕获型分组。

后缀 **?** 表示这个分组是可选的

它表示重复0次或1次。**( .  .  .  )** 表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并把其放到 **result** 数组里。每次捕获分组都会被指定一个编号。第一个捕获分组的编号是1，所以该分组所匹配的文本副本会出现在 **result[1]** 中。 **[ .  .  . ]** 表示一个字符串类。

**A-Za-z** 这个字符类包含26个大写字母和26个小写字母。连字符 **（-）** 表示范围从 **A** 到 **Z** 。后缀 **+** 表示这个字符类型会被匹配一次或多次。这个组后面跟着字符 **:** ,它会按字面进行匹配



<strong><font size = '6'>(\/{0,3})</font></strong>

下一个因子就是捕获分组2. **\/** 表示应该匹配 **/**(斜杠)。它用反斜杠 **\\** 进行转义，这样它就不会被错误的解释为这个正则表达式的结束符。后缀 **{0, 3}** 表示 **/** 会被匹配0次，或者1~3次



<strong><font size = '6'>([0-9.\\-A-Za-z]+)</font></strong>

下一个因子是捕获型分组3。它会匹配一个主机名，由一个或多个数字、字母，以及 **.** 或 **-** 字符组成。

**-** 会被转义为 **\\-** 以防止与表示范围内的连字符相混淆



<strong><font size = '6'>(?::(\d+))?</font></strong>

下一个可选的因子匹配端口号，它是由一个前置 **:** 加上一个或者多个数字组成的序列。 **\d**表示一个数字字符。一个或者多个数字组成的数字串会被捕获型分组4捕获：



<strong><font size = '6'>(?:\/(\[^?#]*))？</font></strong>



接下来是另一个可选的分组。该组以一个 **/** 开始。之后的字符串 **\[^?#]** 以一个 **^** 开始，它表示这个类包括除 **?** 和 **#** 之外的所有字符。 ***** 表示这个字符串会被匹配0次或多次 



注意我在这里的处理是不太严谨的。这个类匹配除了 **?** 和 **#** 之外的所有字符，其中包括了行结束符、控制字符，以及某些大量不应该被匹配的字符。大多数情况下，它会按照我们的预期去做，但某些恶意文本会有渗透进来的风险。不严谨的正则表达式是一个常见的安全漏洞发源地。写不严谨的正则表达式比写严谨的正则表达式要容易得多。



<strong><font size = '6'>(?:\\?(\[^#]*))?</font></strong>

接下来，我们还有一个以一个?开始的可选分组。它包含捕获型分组6，这个分组包含0个或多个非 **#** 字符



<strong><font size = '6'>(?:#(.*))?</font></strong>

我们的最后一个可选分组是以 **#** 开始的。 **.** 会匹配除行结束符以外的所有字符。



<strong><font size = '6'>$</font></strong>

**$** 表示这个字符串的结束。它保证在这个URL的尾部没有其他更多内容了。



parse_url的正则表达式还可以编写得更让复杂，但我不建议这么做。短小精悍的正则表达式是最好的。唯有如此，我们才有信心让他们正确地工作并在需要时能顺利地修改它们。



JavaScript的语言处理程序之间兼容性非常高。这门语言中最没有移植性的部分就是对正则表达式的实现。结构傅瓒而令人费解的正则表达式很可能导致移植性问题。在执行某些匹配时，嵌套的正则表达式也能导致极其恶劣的性能问题。因此简单是最好的策略。



让我们开看另外一个例子：一个匹配数字的正则表达式。数字可能有一个整数部分加上一个可选的负号、一个可选的小数部分和一个可选的指数部分组成：

```javascript
const parse_number = /^-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;

console.log(parse_number.test('1'));
console.log(parse_number.test('number'));
console.log(parse_number.test('98.6'));
console.log(parse_number.test('123.45E-6'));
```

正则表达式对象有一个test方法，返回一个值是不是匹配这个这个正则表达式

‘

parse_number成功地检验出这些字符串中，哪些符合我们的规范，哪些不符合，但对那些不符合的字符串，她并没有告诉我们失败的缘由和位置，



让我们来分析parse_number

<strong><font size = '6'>/^      $/i</font></strong>

我们又用 **^** 和 **$** 来框定这个正则表达式。它指引这个正则表达式对文本中的所有字符进行匹配。如果我们省略了这些标识，那么只要一个字符串包含一个数字，这个正则表达式就会进行匹配。但有了这些标识，只有当一个字符串的内容仅为一个数字时，它才会告诉我们。如果我们仅包含^,，它将匹配以一个数字开头的字符串。如果我们仅包含$，则匹配一个数字结尾的字符串



**i** 标识表示匹配字母时忽略大小写。在我们的模式中唯一可能出现的字母是e，我们希望既能匹配E，又能匹配e，我们可以把e因子写成[Ee]或者(?:E|e)，但不必这么麻烦，因为我们使用了标识符i



-?

负号后面的?后缀表示这个负号是可选的



\d+

\d的含义和[0-9]一样。它匹配一个数字。后缀+指引它可以匹配一个或多个数字



(?:\\.\\d*)?

(?: .  .  .  .)?表示一个可选的非捕获型分组。通常用非捕获型分组来代替少量不优美的捕获型分组是很好的方法，因为捕获会有性能上的损失。这个分组会匹配后面跟随的0个或多个数字的小数点：



(?:e[+\\-]?\\d+)?

这是宁一个可选的非捕获型分组。它会匹配一个e（或EJ)、一个可选的正负号及一个或多个数字



## 结构

有两种方式创建一个正则表达式对象。在以前的例子中我们看到，优先考虑的方法是使用正则表达式字面量

正则表达式字面量被包围在一堆斜杠中，这有点令人难以捉摸。因为斜杠也被用作除法运算和注释符



RegExp能设置三个标识符。它们分别由字母g,i,m来表示。我们把它们列在下面是表中，这些标识被直接添加到RegExp的末尾



| 标识 | 含义                                                |
| ---- | --------------------------------------------------- |
| g    | 全局的（匹配多次；不同的方法对g标识的处理各不相同） |
| i    | 大小写不敏感（忽略字符大小写）                      |
| m    | 多行（^和$能匹配行结束符）                          |



创建一个正则表达式的另一个方法是使用RegExp构造器。这个构造器接受一个字符串。并把它编译为一个RegExp对象。创建这个字符换时要多加小心，因为反斜杠在正则表达式和字符串字面量中有一些不同的含义，通常使用双反斜杠，以及对引号进行转义



第2个参数是一个指定的字符串，RegExp构造器适用于必须在运动时动态生成的正则表达式的情形



| 属性       | 用法                                |
| ---------- | ----------------------------------- |
| global     | 如果属性g被使用，值为true           |
| ignoreCase | 如果标识i被使用，值为true           |
| lastIndex  | 下一次exec匹配开始的索引。初始值为0 |
| multiline  | 如果标识m被使用，值为true           |
| source     | 正则表达式源码文本                  |



让我们进一步看看那些构成正则表达式的元素

一个正则表达式分支包含一个或多个正则表达式序列，这些序列被|分割。如果这些序列中的任何一项符合匹配条件，那么这个选择就被匹配。它尝试按顺序一次匹配这些序列项/所以：

“into”.match(/in|int/)

会在into中匹配in，但它不会匹配int，因为in已经成功匹配了



一个正则表达式序列包含一个或多个正则表达式因子。每个因子能选择是否跟随一个量词，这个量词决定着这个因子被允许出现的次数。如果没有指定这个因子，那么该因子只会被匹配一次。



一个正则表达式因子可以是一个字符、一个由圆括号包围的组，一个字符串，或者是一个转义序列。除了控制字符和特殊数字之外，所有字符都会按照字面处理



如果你希望上面列出的字符按照字面去匹配，那么必须要添加一个\前缀来进行转义。你如果拿不准，可以给任何一个特殊字符添加一个\\前缀来使其字面化。注意\\前缀不会是数字或者字母字面化



当lastIndex属性值j为0时，一个未转义的^会匹配文本的开始。当指定了m标识之后，它也能匹配行结束符



一个未转义的$将匹配文本的结束。当指定了m标识时，它也能匹配行结束符



## 正则表达式转义

反斜杠字符在正则表达式因子中与其在字符串中一样均表示转义，但是在正则表达式中，它稍有一点不同

’像在字符串中一样，\f表示换页符

\r时回车符

\n是换行符

\t是制表符

并且\u是指定一个16位的Unicode字符来表示一个16进制的常量。但在正则表达式中，\b不是退格符

\d等同于[0-9]，它匹配一个数字，\D则表示与其相反的，\[^0-9]

\s等同于\[\f\n\r\t\u00B\u0020\u00A0\u2028\u2019]这是Unicode空白符的一个不完全子集

\S表示与其相反的



## 正则表达式分组







