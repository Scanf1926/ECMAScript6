## 正则表达式

什么是正则表达式呢？举一个大家都比较熟悉的例子。我们在注册账户时，时常提交时浏览器提醒你，你的密码强度不够，或者说你的密码格式不对。

那么浏览器是怎么识别的呢？这就需要用到正则表达式。



正则表达式出奇地复杂和难以阅读，尽管它可以简化，但简化之后又容易变得抽象。所以我们折衷了一下，让代码虽然复杂了一些，却更加容易理解。



在JavaScript中，正则表达式必须写在一行中，空白需要特别注意。

```javascript
const parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
const url = "http://www.ora.com:80/goodparts?q#frament";

const result = parse_url.exec(url);

const names = ['url', 'scheme', 'slash', 'host', 'port', 'path', 'query', 'hash'];
const blanks = '    ';

for(let i = 0; i < names.length; i++) {
    console.log(names[i] + ':' +
    blanks.substring(names[i].length), result[i]);
}
```

这段代码的执行结果如下：

```javascript
url:  http://www.ora.com:80/goodparts?q#frament
scheme: http
slash: //
host: www.ora.com
port: 80
path: goodparts
query: q
hash: frament
```



下面我们要来一步一步分解这个表达式是如何解析的。

​	<strong><font size = '6'>^</font></strong>

表示此字符串的开始。它是一个锚，指引**exec**不要跳过那些不像**URL**的前缀，只匹配那些从开头**URL**一样的字符串



<strong><font size = '6'>(?:([A-Za-z]+):)?</font></strong>

这个银子匹配一个协议名，但仅当它后面跟随一个 **:** (冒号)的时候才匹配。

**(?: .  .  .  .  )** 表示一个非捕获型分组。

后缀 **?** 表示这个分组是可选的

它表示重复0次或1次。**( .  .  .  )** 表示一个捕获型分组。一个捕获型分组会复制它所匹配的文本，并把其放到 **result** 数组里。每次捕获分组都会被指定一个编号。第一个捕获分组的编号是1，所以该分组所匹配的文本副本会出现在 **result[1]** 中。 **[ .  .  . ]** 表示一个字符串类。

**A-Za-z** 这个字符类包含26个大写字母和26个小写字母。连字符 **（-）** 表示范围从 **A** 到 **Z** 。后缀 **+** 表示这个字符类型会被匹配一次或多次。这个组后面跟着字符 **:** ,它会按字面进行匹配



<strong><font size = '6'>(\/{0,3})</font></strong>

下一个因子就是捕获分组2. **\/** 表示应该匹配 **/**(斜杠)。它用反斜杠 **\\** 进行转义，这样它就不会被错误的解释为这个正则表达式的结束符。后缀 **{0, 3}** 表示 **/** 会被匹配0次，或者1~3次



<strong><font size = '6'>([0-9.\\-A-Za-z]+)</font></strong>

下一个因子是捕获型分组3。它会匹配一个主机名，由一个或多个数字、字母，以及 **.** 或 **-** 字符组成。

**-** 会被转义为 **\\-** 以防止与表示范围内的连字符相混淆









