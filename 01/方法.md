[TOC]

JavaScript包含了一套小型的，可以用在标准类型的方法集。

## Array

### array.contact(item...)

contact是合并数组的意思。

concact产生一个新的数组，它包含一个array的浅复制（shallow copy）并把一个或多个参数item附加在其后。如果参数是一个数组，那么它的每一个元素会被分别添加。后面你还会看到和它功能类似的array.push(item...)方法

```javascript
const a = ['a', 'b', 'c'];
const b = ['x', 'y', 'z'];
const c = a.concat(b, true);

console.log(c);	//输出[ 'a', 'b', 'c', 'x', 'y', 'z', true ]
```

### array.join(separator)

join方法把一个array构造成一个字符串。它先把array中的每一个元素构造成一个字符串，接着用一个separator分隔符把它们连接在一起，默认separator是逗号 , 。要想做到无间隔的连接，我们可以使用空字符串作为separator。

如果你想把大量的字符串片段组装成一个字符串，把这些片段放到一个数组中并用join方法通常比用 + 元素运算符连接这些片段要快。

```javascript
const a = ['a', 'b', 'c'];
a.push('d');
const c = a.join('');
const d = a.join(',');

console.log(c);	//输出abcd
console.log(d);	//输出a,b,c,d
```

### array.pop()

pop和push方法使得数组可以像堆栈（stack）一样工作。pop方法移除array中的最后一个元素并返回该元素。如果该array是empty，它会返回undefined

```javascript
const a = ['a', 'b', 'c'];
const tmp = a.pop();

console.log(a);	//输出['a', 'b']
console.log(tmp);	//输出c
```

### array.push(item...)

push方法把一个或多个参数item附加到一个数组的尾部。和concat方法不同的是，它会修改array，如果参数item是一个数组，它会把参数数组作为单个元素整个添加到数组中，并返回这个array的新长度值。

```javascript
const a = ['a', 'b', 'c'];
const b = ['x', 'y', 'z'];
const c = a.push(b, true);

console.log(c);
//a是['a', 'b', 'c', ['x', 'y', 'z'], true]
//c是5
```

### array.reverse()

reverse方法反转array元素的顺序，并返回array本身

```javascript
const a = ['a', 'b', 'c'];
const b = a.reverse();

//这个方法会改变原本的数组
console.log(a);
console.log(b);
```

### array.shift()

shift方法移除数组array中的第1个元素并返回给元素。如果这个数组array是空的，它会返回undefined。shift通常比pop慢得多;

```javascript
const a = ['a', 'b', 'c'];
const c = a.shift();

console.log(c);
```

## array.slice(start, end)

slice方法堆array中的一段做浅复制，首先复制array[start]，一直复制到array[end]为止。end参数是可选的，默认值是该数组的长度array.length。如果两个参数中任何一个是复数，array.length回合它们相加，试图让它们成为非负数。如果start大于等于array.length，得到的结果将是一个空数组。千万别把slice和splice弄混了。字符串也有一个同名的方法，参加本章后面的string.slice

```javascript
const a = ['a', 'b', 'c'];
const b = a.slice(0,1);
const c = a.slice(1);
const d = a.slice(1, 2);

console.log(a);
console.log(b);
console.log(c);
console.log(d);
```

### array.sort(comparefn)

sort方法对array中的内容进行排序，它不能正确地给一组数字排序

```javascript
const num = [4, 8, 15, 16, 23, 42];
num.sort();
console.log(num);
//num执行的结果是[ 15, 16, 23, 4, 42, 8 ]
```

JavaScript的默认方法比较函数把要被排序的方法都视为字符串。它尚未足够智能到在比较这些元素之前先检测它们的类型，所以当它比较这些数字的时候，会把它们转化为字符串，于是得到一个错得离谱的结果。

幸运的是，你可以使用自己的比较函数来替换默认的比较函数。你的比较函数应该接收两个参数，并且如果这两个参数相等则返回0，如果第1个参数应该排列在前面，则返回一个负数。如果第2个参数应该排在前面，则返回一个正数。

```javascript
const num = [4, 8, 15, 16, 23, 42];
//这是一个仅仅可以给数字排序的函数
num.sort(function (a, b) {
  return a - b;
});
console.log(num);
```

上面的这个函数可以使数字正确排序，但它不能使字符串排序。如果我们想要给任何包含简单值的数组排序，必须要做更多的工作：

```javascript
const m = ['aa', 'bb', 'a', 4, 8, 15, 16, 23, 42];
m.sort(function (a, b) {
  if(a == b) {
    return 0;
  }
  if(typeof a === typeof b) {
    return a < b ? -1 : 1;
  }
  return typeof a < typeof b ? -1 : 1;
});
console.log(m);
```

如果大小写不重要，你的比较函数应该在比较之前先将着两个运算符转换为小写。此外请参照本章后面的string.localeCompare

如果有一个更智能的比较函数，我们也可以使对象数组排序。为了让这个事情更能满足一般的情况，我们将编写一个构造比较函数的函数：

```javascript
//by 函数接受一个成员名字符串作为参数
//并返回一个可以用来对包含该成员的对象数组进行排序的比较函数

const by = function (name) {
  return function (o, p) {
    let a, b;
    if(typeof o === 'object' && typeof p === 'object' && o && p) {
      a = o[name];
      b = p[name];
      if(a == b) {
        return 0;
      }
      if(typeof a == typeof b) {
        return a < b ? -1 : 1;
      }
      return typeof a < typeof b ? -1 : 1;
    }
    else {
      throw {
        name: 'Error',
        message: 'Expected an object when sorting by ' + name
      };
    }
  };
};

const s = [
  {first: 'Joe', last: 'Besser'},
  {first: 'Moe', last: 'Howard'},
  {first: 'Joe', last: 'DeRita'},
  {first: 'Shemp', last: 'Howard'},
  {first: 'Larry', last: 'Howard'},
  {first: 'Curly', last: 'Howard'}
];

s.sort(by('first'));

console.log(s);
```

sort方法是不稳定的，所以下面的调用：

```javascript
s.sort(by('first')).sort(by('last'));
```

不能保证产生正确的序列。如果你基于多个键值进行排序，你需要再次做更多的工作。我们可以修改by函数，让其可以接受第2个参数，当主要的键值产生一个匹配的时候，另一个compare方法将被调用以决出高下。

```javascript
//by函数接收一个成员名字符串和一个可选的次要比较函数作为参数，
//并返回一个可以用来对包含该成员的对象数组进行排序的比较函数
//当o[name]和p[name]相等时，次要比较函数被用来决高下

const by = function(name, minor) {
  return function (o, p) {
    let a, b;
    if(o && p && typeof o === 'object' && typeof p === 'object') {
      a = o[name];
      b = p[name];
      if(a == b) {
        return typeof minor === 'function' ? minor(o, p) : 0;
      }
      if(typeof a === typeof b) {
        return a < b ? -1 : 1;
      }
      return typeof a < typeof b ? -1 : 1;
    }
    else {
      throw {
        name: 'Error',
        message: 'Expected an object when sorting by ' + name
      };
    }
  };
}

const s = [
  {first: 'Joe', last: 'Besser'},
  {first: 'Moe', last: 'Howard'},
  {first: 'Joe', last: 'DeRita'},
  {first: 'Shemp', last: 'Howard'},
  {first: 'Larry', last: 'Howard'},
  {first: 'Curly', last: 'Howard'}
];

s.sort(by('last', by('first')));

console.log(s);
```

### array.splice(start, deleteCount, item...)

splice方法从array中移除一个或多个元素，并用新的item替换它们。参数start是从array数组中移除元素的开始位置。参数deleteCount是要移除的元素个数。如果有额外的参数，那些item会插入到被移除的位置上。它返回一个包含被移除元素的数组。

splice最主要的用处是从一个数组中删除元素。千万不要把splice和slice弄混淆了。

```javascript
const a = ['a', 'b', 'c'];
const r = a.splice(1, 1, 'ache', 'bug');

console.log(a);
console.log(r);
```



### array.unshift(item...)

unshift方法像push方法一样，用于把元素添加到数组中，但它是把item插入到array的开始部分而不是尾部。它返回array的新length

```javascript
const a = ['a', 'b', 'c'];
const b = a.unshift('d');

console.log(a);
console.log(b);
```





## Function

### function.apply(thisArg, argArray)

applay方法调用function，传递一个会被绑定到this上的对象和一个可选的数组作为参数。apply方法被用在apply调用模式中



## Number

### number.toExponential(fractionDigits)

toExponential方法把这个number转换成一个指数形式的字符串。可选参数fractionDigits控制器小数点后的数字位数。它的值必须在0~20

```javascript
//先看js中定义的PI是怎么样的
console.log(Math.PI);


console.log(Math.PI.toExponential(0));
console.log(Math.PI.toExponential(2));
console.log(Math.PI.toExponential(7));
console.log(Math.PI.toExponential());
```

### number.toFixed(fractionDigits)

toFixed方法把这个number转换成为一个十进制形式的字符串。可选参数fractionDigits控制其小数点后的数字位数。它的值必须在0~20之间，默认为0

```javascript
console.log(Math.PI);

console.log(Math.PI.toFixed(0));
console.log(Math.PI.toFixed(2));
console.log(Math.PI.toFixed(7));
console.log(Math.PI.toFixed());
```

### number toPrecision(precision)

toPrecision方法把这个number转换成为一个十进制数形式的字符串。可选参数precision控制数字的精度，它的值必须在0~21

```javascript
console.log(Math.PI.toPrecision(2));
console.log(Math.PI.toPrecision(7));
console.log(Math.PI.toPrecision(16));
console.log(Math.PI.toPrecision());
```

### number.toString(radix)

toString方法把这个number转换为一个字符串。可选参数radix控制基数。它的值必须在2~36。默认radix是以10为基础的。radix参数最常用的是整数，但是它可以用任意的数字

```javascript
console.log(Math.PI.toString(2));   //转换为2进制
console.log(Math.PI.toString(8));   //转换为8进制
console.log(Math.PI.toString(16));  //转换为16进制
console.log(Math.PI.toString());    //默认是10进制
```



## Object

## object.hasOwnProperty(name)

如果这个object包含一个名为name的属性，那么hasOwnProperty方法返回true。原型链中的同名属性是不会被检查的。这个方法对name就是“hasOwnProperty”时不起作用，此时会返回false

```javascript
const a = {member: true};
const b = Object.create(a);
const t = a.hasOwnProperty('member');   //t是true
const f = b.hasOwnProperty('member');   //f是false
const v = b.member;   //v是true

console.log(t);
console.log(f);
console.log(v);
```



## RegExp

### regexp.exec(string)

exec方法是使用正则表达式最强大（和最慢）的方法。如果它成功地匹配regexp和字符串string，它会返回一个数组。数组中下标为0的元素将包含正则表达式regexp匹配的字符串。下表为1的元素是分组1捕获的文本，下标为2的元素是分组2捕获的文本，依此类推。如果匹配失败，它会返回null

如果regexp带有一个g标识（全局标识），事情就会变得复杂。查找不是从这个字符串起始位置开始，而是从regexp.lastIndex（初始值为0）位置开始。不成功的匹配会重置regexp.lastIndex为0

这就允许你通过循环调用exec去查询一个字符串中发生即此。有两件事情需要注意。如果你提前退出了这个循环，再次进入这个循环前必须把regexp.lastIndex重置到0。而且，^因子仅匹配regexp.lastIndex为0的情况。

```javascript
//示例代码报错
```



### regexp.test(string)

test方法是使用正则表达式的最简单（和最快）的方法。如果该regexp匹配string，它返回true；否则，它返回false。不要对这个方法使用g标识

```javascript
const b = /&.+;/.test('frank &amp; beans');
console.log(b);
```



## String

## string.charAt(pos)

charAt方法返回在string中pos位置处的字符串。如果pos小于0或大于等于字符串的长度string.length，他就会返回空字符串。JavaScript没有字符类型。这个方法返回的结果是一个字符串。

```javascript
const name = 'Curly';
const initial = name.charAt(0);

console.log(initial);
```

 ### string.charCodeAt(pos)

charCodeAt方法同charAt一样，只不过它返回的不是一个字符串，而是以整数的形式表示的在string中的pos位置处的字符的字符码位。如果pos小于0或者大于等于字符串的长度string.length，它返回NaN

```javascript
const name = 'Curly';
const initial = name.charCodeAt(0);

//在ASCII码表中，C的编号就是67
console.log(initial);
```

### string.concat(string...)

concat方法把其他字符串连接在一起来构造一个新的字符串。它很少被使用，因为用 + 运算符更加方便：

```javascript
const s = 'C'.concat('a', 't');
console.log(s);
```

### string.indexOf(searchString, position)

indexOf方法在string内查找另一个字符串searchString。如果它被找到，返回第一个字符串的位置，否则返回-1.可选参数position可设置从string的某个位置开始查找：

```javascript
const text = 'Messissippi';

let p = text.indexOf('ss');
console.log(p);

p = text.indexOf('ss', 3);
console.log(p);

p = text.indexOf('ss', 6);
console.log(p);
```

### string.lastIndexOf(searchString, position)

lastIndexOf方法和indexOf方法类似，只不过它是从该字符串的末尾开始查找而不是从开头

```javascript
const text = 'Messissippi';

let p = text.lastIndexOf('ss');
console.log(p);

p = text.lastIndexOf('ss', 3);
console.log(p);

p = text.lastIndexOf('ss', 6);
console.log(p);
```

### string.localeCompare(that)

localeCompare方法比较两个字符串。如何比较字符串的规则没有详细说明。如果string比字符串that小，那么结果为负数。如果它们是相等的，那么结果为0.这类似于array.sort比较函数的约定：

```javascript
const m = ['AAA', 'A', 'aa', 'a', 'Aa', 'aaa'];
m.sort(function (a, b) {
  return a.localeCompare(b);
});

console.log(m);
```

### string.match(regexp)

match方法让字符串和一个正则表达式进行匹配。它依据g标识来决定如何进行匹配。如果没有g标识，那么调用string.match(regexp)的结果与调用regexp.exec(string)的结果相同。然而，如果regexp带有g标识，那么它生成一个包含所有匹配（除捕获分组之外）的数组

```javascript
const text = '<html><body bgcolor=#faf0e6><p>' +
    'This is <b>body<\/b>!<\/p><\/body><\/html>';
const tags = /[^<>]+|<(\/?)([A-Za-z]+)([^<>]*)>/g;
let a, i;
a = text.match(tags);
for(i = 0; i < a.length; i++) {
  console.log(('// [' + i + '] ' + a[i]));
}
```

结果是：

```
// [0] <html>
// [1] <body bgcolor=#faf0e6>
// [2] <p>
// [3] This is 
// [4] <b>
// [5] body
// [6] </b>
// [7] !
// [8] </p>
// [9] </body>
// [10] </html>
```

 

### string.replace(searchValue, replaceValue)

replace方法对string进行查找和替换操作，并返回一个新的字符串。参数searchValue可以是一个字符串或者一个正则表达式对象。如果它是一个字符串，那么searchValue只会在第1次出现的地方被替换，所以下面代码的结果是“mother-in_law”：

```javascript
const result = "mother_in_law".replace('_', '-');
console.log(result);
```

这或许令你失望。

如果searchValue是一个正则表达式并且带有g标识，它会替换所有的匹配。如果没有带有g标识，它会仅仅替换第1个匹配。、

replaceValue可以是一个字符串或一个函数。如果replaceValue是一个字符串，字符串$拥有特别的含义：

```javascript
const oldareacode = /\((\d{3})\)/g;
const p = '(555)666-1212'.replace(oldareacode, '$1-');

console.log(p);
```

| 美元符号序列 | 替换对象       |
| ------------ | -------------- |
| $$           | $              |
| $&           | 整个匹配的文本 |
| $number      | 分组匹配的文本 |
| $`           | 匹配之前的文本 |
| $'           | 匹配之后的文本 |

### string.search(regexp)

search方法与indexOf方法类似，只是它接受一个正则表达式对象作为参数而不是一个字符串。如果找到匹配，它返回第1个匹配的首字符位置，如果没有找到匹配，则返回-1.此方法会忽略g标识，且没有position参数

```javascript
const text = 'and in it he says "Any damn fool could';
const pos = text.search(/["']/);
console.log(pos);
```

### string.slice(start, end)

slice方法复制string的一部分来构造字符串。如果start参数是负数，它将与string.length相加。end参数是可选的，且默认值是string.length。如果end参数是负数，那么它将与string.length相加。end参数等于你要取的最后一个字符的位置值加上1。要想得到从位置p开始的n个字符，就用string.slice(p, p + n)。同类的方法参加本章随后要介绍的string.sunstring和之前介绍的array.slice

```javascript
const text = 'and in it he says "Any damn fool could';
const a = text.slice(18);
console.log(a);
const b = text.slice(0, 3);
console.log(b);
const c = text.slice(-5);
console.log(c);
```

### string.split(separator, limit)

split方法把这个string分割成片段来创建字符串数组。可选参数limit可以限制被分割的片段数量。seperator参数可以是一个字符串或者一个正则表达式

如果separator是一个空字符串，会返回一个单字符的数组

```javascript
const digits = '0123456789';
const a = digits.split('', 5);
console.log(a);
```

否则，此方法会在string查找所有的separator出现的地方。分隔符两边的每个单元文本都会复制到该数组中。此方法会忽略到g标识

```javascript
const ip = '192.168.1.0';
const b = ip.split('.');
console.log(b);
```

### string.substring(start, end)

substring的用法和slice方法一样，只是它不能处理负数参数。没有任何理由取使用substring方法。请用slice方法替换它。

### string.toLocaleLowerCase()

toLocaleLowerCase()方法返回一个新字符串，它使用本土化的规则把这个string中所有的字母转换为小写格式。这个方法主要用于土耳其语，因为土耳其的大小写有点不一样。

### string.toLocaleUpperCase()

toLocaleUpperCase()方法返回一个新字符串，它使用本土化的规则把这个string中所有的字母转换为大写格式。这个方法主要用于土耳其语，因为土耳其的大小写有点不一样。

### string.toLowerCase()

此方法返回一个新字符串，这个string中的所有字母均转换为小写格式

### string.toUpperCase()

此方法返回一个新字符串，这个string中的所有字母均转换为大写格式

### String.fromCharCode(char...)

String.formCharCode 函数根据一串数字编码返回一个字符串

```javascript
const a = String.fromCharCode(67, 97, 116);
console.log(a);
```

